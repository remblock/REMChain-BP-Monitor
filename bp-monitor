#!/bin/bash

#****************************************************************************************************#
#                                        REMCHAIN-BP-MONITOR                                         #
#****************************************************************************************************#

#----------------------------------------------------------------------------------------------------#
# IF THE USER HAS NO ROOT PERMISSIONS THE SCRIPT WILL EXIT                                           #
#----------------------------------------------------------------------------------------------------#

if (($EUID!=0))
then
  echo "You must be root to run this script" 2>&1
  exit 1
fi

#----------------------------------------------------------------------------------------------------#
# CRON LINE WILL BE CREATED FOR THE BP MONITORING SCRIPT                                             #
#----------------------------------------------------------------------------------------------------#

bp_mon_cron_line="* * * * * /root/remblock/bp-monitor/bp-monitor"

#----------------------------------------------------------------------------------------------------#
# START AND STOP SERVER COMMANDS FILES PATH                                                          #
#----------------------------------------------------------------------------------------------------#

start_server_commands_path="/root/remblock/bp-monitor/start_server_commands"
stop_server_commands_path="/root/remblock/bp-monitor/stop_server_commands"
service_definition_path="/etc/systemd/system/autobot.service"

#----------------------------------------------------------------------------------------------------#
# CREATE START AND STOP SERVICES                                                                     #
#----------------------------------------------------------------------------------------------------#

function create_start_stop_service {
  if [ ! -f "$start_server_commands_path" ]
  then
cat << 'DOC' > "$start_server_commands_path"
#!/bin/sh
/usr/bin/nohup /usr/bin/remnode --config-dir /root/config/ --data-dir /root/data/ >>/root/remnode.log 2>>/root/remnode.log &
sleep 30
if ! tail -n1 /root/remnode.log | grep 'on_incoming_block' &>/dev/null
then
   /usr/bin/nohup /usr/bin/remnode --config-dir  /root/config/ --data-dir /root/data/ --replay-blockchain --hard-replay-blockchain --genesis-json genesis.json &
fi
DOC
chmod u+x "$start_server_commands_path"
fi
if [ ! -f "$stop_server_commands_path" ]
then
cat << 'DOC' > "$stop_server_commands_path"
#!/bin/sh
/usr/bin/killall remcli
sleep 15
DOC
chmod u+x $stop_server_commands_path
fi
if [ ! -f "$service_definition_path" ]
then
cat << DOC > "$service_definition_path"
[Unit]
Description=RUN REMCLI COMMANDS AT START AND STOP
[Service]
Type=oneshot
RemainAfterExit=true
ExecStart=$start_server_commands_path
ExecStop=$stop_server_commands_path
[Install]
WantedBy=multi-user.target
DOC
systemctl enable autobot &> /dev/null
fi
}

#----------------------------------------------------------------------------------------------------#
# THIS SCRIPT NEED TO BE CALLED VIA CRON EVERY MINUTE                                                #
#----------------------------------------------------------------------------------------------------#

#PATH to used commands
PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/snap/bin"

#----------------------------------------------------------------------------------------------------#
# LOAD CONFIGURATION VARIABLES AND VALUES                                                            #
#----------------------------------------------------------------------------------------------------#

source "/root/remblock/monitor/config" &>/dev/null
now_epoch="$(date +%s)"
now_date="$(date +%d-%m-%Y)"
accountname="$accountname"

#----------------------------------------------------------------------------------------------------#
# INSTALL CRONTAB LINE IF IT DOESN'T EXIST
#----------------------------------------------------------------------------------------------------#

if [ ! -z "$bpm_cron_cmd" ] && ! crontab -u root -l | grep -v '^ *#' | grep "$bpm_cron_cmd" &>/dev/null
then
  (crontab -u root -l ; echo "*/1 * * * * $bpm_cron_cmd") | crontab -u root -
fi

#----------------------------------------------------------------------------------------------------#
# CREATE BP MONITOR FOLDER FOR TEMP INFORMATION
#----------------------------------------------------------------------------------------------------#

if [ ! -z "$bpm_temp_dir" ] && [ ! -d "$bpm_temp_dir" ]
then
  mkdir "$bpm_temp_dir"
fi

#****************************************************************************************************#
#                                        FUNCTION DEFINITIONS                                        #
#****************************************************************************************************#

#Add a message to be sent later, if there are more lines than permited in the queue, delete the older ones

function add_message_to_queue(){
  #If the log is at maximum capacity, delete exceding lines
  if [ -f "$bpm_temp_dir/msg_queue.txt" ] && (( $(wc -l "$bpm_temp_dir/msg_queue.txt" | awk '{print $1}') >= bpm_max_queued_msg_lines ))
  then
    echo "$(tail -$((bpm_max_queued_msg_lines -1)) $bpm_temp_dir/msg_queue.txt)" > $bpm_temp_dir/msg_queue.txt
  fi
  if ! line_repeated "$1"
  then
    echo -e "$1\n" >> "$bpm_temp_dir/msg_queue.txt"
  fi
}

#****************************************************************************************************#
# CHECK IF THE LAST LINE IS REPEATED                                                                 #
#****************************************************************************************************#

function line_repeated(){
  if grep "$1" "$bpm_temp_dir/msg_queue.txt" &>/dev/null
  then
    return 0
  else
    return 1
  fi
}

#****************************************************************************************************#
# REMOVE OLD LINES THAT ONLY CHANGE IN MINUTES DISPLAYED                                             #
#****************************************************************************************************#

# It receives only the base of the line befores the numbers curresponding to time

function remove_lines_repeated_time(){
  sed -i "/^$1/d" "$bpm_temp_dir/msg_queue.txt"
}

#Remove 2 consecutive empty lines before sending the message
function remove_empty_lines(){
  sed -i '/^$/{N;/^\n$/d;}' "$bpm_temp_dir/msg_queue.txt"
  #if the first line is empty, delete it
  if ! [[ "$(head -1 $bpm_temp_dir/msg_queue.txt)" =~ [a-zA-Z0-9] ]]
  then
    sed -i '1d' "$bpm_temp_dir/msg_queue.txt"
  fi
}

#Send the queued messages to telegram and empty the queue
function send_telegram_messages(){
  if [ ! -z "$telegram_token" ] && [ ! -z "$telegram_chatid" ]
  then
    remove_empty_lines
    curl -s -X POST https://api.telegram.org/bot$telegram_token/sendMessage -d chat_id=$telegram_chatid -d text="$(echo -e "BP Warning Alert\n--------------------------------------";cat $bpm_temp_dir/msg_queue.txt)" &>/dev/null
    #clean the msg queue file
    > $bpm_temp_dir/msg_queue.txt
    echo $now_epoch > "$bpm_temp_dir/last_send_message_epoch.txt"
  fi
}

#Check warning threshold and send message
function send_warnings(){
  if [ ! -f "$bpm_temp_dir/last_send_message_epoch.txt" ]
  then
    echo $now_epoch > "$bpm_temp_dir/last_send_message_epoch.txt"
  else
    config_minutes_in_seconds="$((bpm_warning_alert_threshold * 60))"
    last_msg_epoch=$(cat "$bpm_temp_dir/last_send_message_epoch.txt")
    if (( (now_epoch - last_msg_epoch) >= config_minutes_in_seconds )) && (( $(wc -l "$bpm_temp_dir/msg_queue.txt" | awk '{print $1}') > 1 ))
    then
      send_telegram_messages
    fi
  fi
}

#Translate the time format from the remnode log to epoch time
function remnodelogtime_to_epoch(){
  temp_date="$( echo $1 | awk -F '.' '{ print $1}' | tr '-' '/' | tr 'T' ' ')"
  echo $(date "+%s" -d "$temp_date")
}

#Function that checks if whether the node has actual produced a block within the past configured max minutes.
function check_produce_minutes(){
  last_block_date=$(grep -i "signed by $accountname" $bpm_remnode_log | sed -n '$p' | awk '{print $2}')
  last_block_epoch=$(remnodelogtime_to_epoch "$last_block_date")
  config_minutes_in_seconds="$((bpm_check_produce_minutes * 60))"
  if (( (now_epoch - last_block_epoch) >= config_minutes_in_seconds ))
  then
    remove_lines_repeated_time "$accountname last produced a block"
    add_message_to_queue "$accountname last produced a block "$(((now_epoch - last_block_epoch)/60))" minutes ago."
  fi
}

#Function that checks whether the remnode.log file has been modified within the past configured max minutes
function check_log_minutes(){
  last_write_epoch=$(date +%s -r "$bpm_remnode_log")
  config_minutes_in_seconds="$(( bpm_check_log_minutes * 60))"
  if (( (now_epoch - last_write_epoch) >= config_minutes_in_seconds ))
  then
    remove_lines_repeated_time "$accountname log file was last modified"
    add_message_to_queue "$accountname log file was last modified "$(((now_epoch - last_write_epoch)/60))" minutes ago"
  fi
}

#Function that checks the condition of the remnode chain
function check_remnode_chain(){
  if ! timeout 10s remcli get info 2>&1 | grep server_version &>/dev/null
  then
    add_message_to_queue "$accountname failed to receive a response from \"remcli get info\""
  fi
}

#Function that checks gap between head block (head_block_num) and last irreversible block (last_irreversible_block_num) to see if it has been more than the configured minutes
function check_block_minutes(){
  if ! timeout 10s remcli get info 2>&1 | grep server_version &>/dev/null
  then
    add_message_to_queue "$accountname failed to receive a response from \"remcli get info\""
    return
  fi
  last_block_id="$(remcli get info | grep -w 'head_block_num' | awk '{print $2}' | tr -d ',')"
  last_irr_block_id="$(remcli get info | grep -w 'last_irreversible_block_num' | awk '{print $2}' | tr -d ',')"
  last_block_date=$(grep -i "#$last_block_id" $bpm_remnode_log | sed -n '$p' | awk '{print $2}')
  last_irr_block_date=$(grep -i "#$last_irr_block_id" $bpm_remnode_log | sed -n '$p' | awk '{print $2}')
  last_block_epoch=$(remnodelogtime_to_epoch "$last_block_date")
  last_irr_block_epoch=$(remnodelogtime_to_epoch "$last_irr_block_date")
  config_minutes_in_seconds="$((bpm_check_block_minutes * 60))"
  if (( ( last_block_epoch - last_irr_block_epoch ) >= config_minutes_in_seconds ))
  then
    remove_lines_repeated_time "$accountname current block is"
    add_message_to_queue "$accountname current block is $(((last_block_epoch - last_irr_block_epoch)/60)) ahead of last irreversible."
  fi
}

#Function that checks if the last irreversible block has not advanced.
function check_last_iblock(){
  if ! timeout 10s remcli get info 2>&1 | grep server_version &>/dev/null
  then
    add_message_to_queue "$accountname failed to receive a response from \"remcli get info\""
    return
  fi
  if [ ! -f "$bpm_temp_dir/last_iblock.txt" ]
  then
    last_irr_block_id="$(remcli get info | grep -w 'last_irreversible_block_num' | awk '{print $2}' | tr -d ',')"
    echo "$last_irr_block_id" > "$bpm_temp_dir/last_iblock.txt"
  else
    last_block_id=$(cat "$bpm_temp_dir/last_iblock.txt")
    last_irr_block_id="$(remcli get info | grep -w 'last_irreversible_block_num' | awk '{print $2}' | tr -d ',')"
    if [ "$last_block_id" == "$last_irr_block_id" ]
    then
      remove_lines_repeated_time "$accountname last irreversible block is stuck on"
      add_message_to_queue "$accountname last irreversible block is stuck on ${last_irr_block_id}."
    else
      echo "$last_irr_block_id" > "$bpm_temp_dir/last_iblock.txt"
    fi
  fi
}

#Function that tests the "remcli net peers" command for the last handshake time, if the peer time is older than the configured minutes
function check_net_peers(){
  if ! timeout 10 remcli net peers | grep head_id &>/dev/null
  then
    add_message_to_queue "$accountname failed to receive a response from \"remcli net peers\""
    return
  fi
  last_hand_shake_time_ns="$(remcli net peers | grep time | sed -n '1p' | awk '{print $2}' | tr -d '",')"
  #removing nanoseconds for calculations
  last_hand_shake_epoch="${last_hand_shake_time_ns:-9}"
  config_minutes_in_seconds="$((bpm_check_peers_minutes * 60))"
  if (( ( now_epoch - last_hand_shake_epoch ) >= config_minutes_in_seconds ))
  then
    add_message_to_queue "$accountname peer handshake never took place."
  fi
}

#Send alerts if disk or ram exceeds the threshold
function check_disk_and_ram(){
  ram_used_perc="$(free | grep Mem | awk '{print $3/$2 * 100.0}' | awk -F '.' '{print $1}')"
  max_ram="$(echo $bpm_ram_usage_threshold | tr -d '%' )"
  disk_used_perc="$(df -h | grep -w '/' | awk '{print $5}' | tr -d '%')"
  max_disk="$(echo $bpm_disk_space_threshold | tr -d '%' )"
  if (( ram_used_perc >= max_ram ))
  then
    add_message_to_queue "$accountname ram usage is over the specified threshold amount."
  fi
  if (( disk_used_perc >= max_disk ))
  then
    add_message_to_queue "$accountname disk usage is over the specified threshold amount."
  fi
}

#****************************************************************************************************#
#                                       MAIN PROGRAM FUNCTIONS                                       #
#****************************************************************************************************#

if [ "$(echo $bpm_check_producer | tr '[:upper:]' '[:lower:]' )" == "true" ]
then
  check_produce_minutes
fi

if [ "$(echo $bpm_check_log | tr '[:upper:]' '[:lower:]' )" == "true" ]
then
  check_log_minutes
fi

if [ "$(echo $bpm_check_info | tr '[:upper:]' '[:lower:]' )" == "true" ]
then
  check_remnode_chain
fi

if [ "$(echo $bpm_check_blocks | tr '[:upper:]' '[:lower:]' )" == "true" ]
then
  check_block_minutes
fi

if [ "$(echo $bpm_check_irr_blocks | tr '[:upper:]' '[:lower:]' )" == "true" ]
then
  check_last_iblock
fi

if [ "$(echo $bpm_check_peers | tr '[:upper:]' '[:lower:]' )" == "true" ]
then
  check_net_peers
fi

if [ "$(echo $bpm_check_server | tr '[:upper:]' '[:lower:]' )" == "true" ]
then
  check_disk_and_ram
fi

send_warnings

#----------------------------------------------------------------------------------------------------#
# CREATE BP-MONITOR CONFIG FILE                                                                      #
#----------------------------------------------------------------------------------------------------#

if ! grep 'bpm_temp_dir' "$bp_monitor_config_path" &>/dev/null
then
cat << 'DOC' >> "$bp_monitor_config_path"
bpm_cron_cmd="/root/remblock/autobot/bp-monitor"
bpm_temp_dir="/root/remblock/autobot/bp-monitor_temp"
bpm_remnode_log="/root/remnode.log"
bpm_warning_alert_threshold=3
bpm_check_produce_minutes=3
bpm_max_queued_msg_lines=50
bpm_check_log_minutes=3
bpm_check_block_minutes=3
bpm_check_peers_minutes=3
bpm_ram_usage_threshold=80
bpm_disk_space_threshold=80
bpm_check_producer=true
bpm_check_log=false
bpm_check_info=false
bpm_check_blocks=false
bpm_check_irr_blocks=false
bpm_check_peers=false
bpm_check_server=true
DOC
#Run the script a first time so it create the crontab line
bash $bp_monitor_script_path &>/dev/null
fi
}
